% chapters/chapter1.tex
\documentclass[../main.tex]{subfiles}

\begin{document}
	
	\section{Algorithmen}
%		TEMPLATE
	%\subsection{title}
	%GENERELLE INFO. \\\\
	%\textbf{Anwendungsfälle:}\\
	%	- TEXT\\
	%	- TEXT\\\\
	%\textbf{Implementation:}\\
	%\lstinputlisting[language=Java]{code/alg.java} 
	%\textbf{Laufzeitkomplexität}\\
	%\begin{table}[ht]
	%	\centering
	%	\begin{tabular}{l *{3}{c}}
	%		\toprule
	%		Operation & Best & Average & Worst\\
	%		\midrule
	%		Time Complexity & $O(1)$ & $O(n)$ & $O(1)$\\
	%		\bottomrule
	%	\end{tabular}
	%\end{table}
	%\clearpage		

	\subsection{Suchalgorithmen}
	\subsubsection{Lineare Suche}
	Die lineare Suche (Auch sequentielle Suche) ist ein Suchalgorithmnus, der ein Element innerhalb einer Liste finden soll.
	Dabei wird sequenziell jedes Element der Liste durchsucht, bis das gesuchte Element gefunden wurde.\\\\
	\textbf{Anwendungsfälle:}\\
		- Wenn Liste relativ klein ($\leq100$)\\
		- Wenn Liste unsortiert\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/LineareSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(n)$ & $O(n)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsubsection{Binäre Suche}
	Die binäre Suche ist ein Suchalgorithmus, der eine sortierte Liste voraussetzt.
	Das Prinzip der binären Suche ist, dass der Suchbereich immer weiter eingeschränkt wird (Effektiv halbiert). 
	Dazu wird der Median (mittlere Wert) des Suchbereichs genommen. 
	Ist dieser Median Größer als der gesuchte Wert, so wird die kleinere Hälfte des Suchbereichs als neuen Suchbereich festgelegt.
	Analog wird bei größerem Median die größere Hälfte verwendet.\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/BinaereSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(log(n))$ & $O(log(n))$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage

	\subsection{Sortieralgorithmen}
	\subsubsection{Selection Sort}
	GENERELLE INFO. \\\\
	\textbf{Anwendungsfälle:}\\
	- TEXT\\
	- TEXT\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/LineareSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(n)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsubsection{Insertion Sort}
	GENERELLE INFO. \\\\
	\textbf{Anwendungsfälle:}\\
	- TEXT\\
	- TEXT\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/LineareSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(n)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsubsection{Merge Sort}
	GENERELLE INFO. \\\\
	\textbf{Anwendungsfälle:}\\
	- TEXT\\
	- TEXT\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/LineareSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(n)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsubsection{Quick Sort}
	GENERELLE INFO. \\\\
	\textbf{Anwendungsfälle:}\\
	- TEXT\\
	- TEXT\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/LineareSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(n)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsection{Graphalgorithmen}
	\subsubsection{Breitensuche (BFS)}
	GENERELLE INFO. \\\\
	\textbf{Anwendungsfälle:}\\
	- TEXT\\
	- TEXT\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/LineareSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(n)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsubsection{Tiefensuche (DFS)}
	GENERELLE INFO. \\\\
	\textbf{Anwendungsfälle:}\\
	- TEXT\\
	- TEXT\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/LineareSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(n)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsubsection{Dijkstra (Shortest Path)}
	GENERELLE INFO. \\\\
	\textbf{Anwendungsfälle:}\\
	- TEXT\\
	- TEXT\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/LineareSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(n)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsubsection{Kruskal (Min. Spannbaum)}
	GENERELLE INFO. \\\\
	\textbf{Anwendungsfälle:}\\
	- TEXT\\
	- TEXT\\\\
	\textbf{Implementation:}\\
	\lstinputlisting[language=Java]{code/LineareSuche.java} 
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Best & Average & Worst\\
			\midrule
			Time Complexity & $O(1)$ & $O(n)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
\end{document}

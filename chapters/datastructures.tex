% chapters/chapter1.tex
\documentclass[../main.tex]{subfiles}

\begin{document}
	
	\section{Datenstrukturen}
%		TEMPLATE
%		\subsection{ArrayList}
%		GENERELLE INFO. \\\\
%		\textbf{Anwendungsfälle:}\\
%		- TEXT\\
%		- TEXT\\\\
%		\textbf{Syntax:}
%		\lstinputlisting[language=Java]{code/ArrayList.java} 
%		\\
%		\textbf{Funktionalität unter der Haube:}\\
%		- TEXT\\
%		- TEXT\\\\
%		\textbf{Laufzeitkomplexität}\\
%		\begin{table}[ht]
%			\centering
%			\begin{tabular}{l *{6}{c}}
%				\toprule
%				Operation & Add & Remove & Get & Contains & Next & Size \\
%				\midrule
%				Time Complexity & $O(1)$ & $O(n)$ & $O(1)$ & $O(n)$ & $O(1)$ & $O(1)$ \\
%				\bottomrule
%			\end{tabular}
%		\end{table}
%		\clearpage		
	
		\subsection{ArrayList}
		Die ArrayList in Java ist eine dynamisch wachsende Liste, die auf dem zugrunde liegenden Array basiert.
		Sie erweitert die Funktionalität von Arrays durch automatische Größenanpassung und bietet eine flexible Möglichkeit, Elemente hinzuzufügen, zu löschen und darauf zuzugreifen. \\\\
		\textbf{Anwendungsfälle:}\\
		- Speicherung von Elementen einer Liste\\
		- Zugriff auf Elemente durch Index\\
		- Wenn die Größe der Liste nicht im Voraus bekannt ist\\ 
		- Wenn häufiger Einfüge- und Löschoperationen erforderlich sind\\\\
		\textbf{Syntax:}
		\lstinputlisting[language=Java]{code/ArrayList.java} 
		\\
		\textbf{Funktionalität unter der Haube:}\\
		- Intern durch Array verwaltet, welches ggf. neu dimensioniert werden muss\\
		- Neudimensionierung führt zu O(n), da neues Array und alle Elemente kopiert werden. Wird allerdings selten gemacht und dann i.d.R. direkt verdoppelt, somit amortisiert O(1)\\\\
		\textbf{Laufzeitkomplexität}\\
		\begin{table}[ht]
			\centering
			\begin{tabular}{l *{6}{c}}
				\toprule
				Operation & Add & Remove & Get & Contains & Next & Size \\
				\midrule
				Time Complexity & $O(1)$ & $O(n)$ & $O(1)$ & $O(n)$ & $O(1)$ & $O(1)$ \\
				\bottomrule
			\end{tabular}
		\end{table}
		\clearpage
		
		
		\subsection{LinkedList}
		Dynamische Datenstruktur bestehend aus Knoten, die jeweils auf den nächsten Knoten in der Sequenz zeigen
		Zwei Haupttypen: Singly Linked (Zeigt nur auf Nachfolger), Doubly Linked (Zeigt  auf Vor- und Nachfolger).\\\\
		\textbf{Anwendungsfälle:}\\
		- Bei häufigen Einfüge- und Löschoperationen an verschiedenen Positionen\\
		- Wenn die Größe der Liste variabel ist\\\\
		\textbf{Syntax:}
		\lstinputlisting[language=Java]{code/ArrayList.java} 
		\\
		\textbf{Funktionalität unter der Haube:}\\
		- Jeder Knoten erhält Verweise auf Nach- (ggf. Vorgänger)\\
		- Einfügen und Löschen an am Ende/Anfang konstant, ansonsten linear, da update der Verweise\\\\
		\textbf{Laufzeitkomplexität}\\
		\begin{table}[ht]
			\centering
			\begin{tabular}{l *{6}{c}}
				\toprule
				Operation & Add & Remove & Get & Contains & Next & Size \\
				\midrule
				Time Complexity & $O(1)$ & $O(1)$ & $O(n)$ & $O(n)$ & $O(1)$ & $O(1)$ \\
				\bottomrule
			\end{tabular}
		\end{table}
	\clearpage
		
		
	\subsection{Stack}
	Agiert nach \textbf{L}ast-\textbf{I}n-\textbf{F}irst-\textbf{O}ut (\textbf{LIFO}) Prinzip: Das letzte hinzugefügte Element wird als Erstes entfernt.
	Unterstützt lediglich Hinzufügen (Push) und Entfernen (Pop). \\\\
	\textbf{Anwendungsfälle:}\\
	- Rückverfolgung von Funktionsaufrufen (Call Stack Aufbau bspw.)\\
	- Umkehrung von Zeichenketten/Ausdrücken\\
	- Undo-Mechanismen\\\\
	\textbf{Syntax:}
	\lstinputlisting[language=Java]{code/Stack.java} 
	\\
	\textbf{Funktionalität unter der Haube:}\\
	- Ein Stack kann durch ein Array oder eine verkettete Liste implementiert werden\\
	- Die Elemente werden auf dem Stack oben hinzugefügt und entfernt\\
	- Schnelle Hinzufüge- und Entfernungsoperationen (konstante Laufzeit O(1))\\
	- Keine Suchmöglichkeit, ggf. aber Möglichkeit oberstes Element anzuschauen (peek)\\
	- Custom Suche implementierbar, dann O(n) wahrscheinlich\\\\
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{2}{c}}
			\toprule
			Operation & Push & Pop  \\
			\midrule
			Time Complexity & $O(1)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsection{Queue}
	Agiert nach \textbf{F}irst-\textbf{I}n-\textbf{F}irst-\textbf{O}ut (\textbf{FIFO}) Prinzip: Das letzte hinzugefügte Element wird als Erstes entfernt.
	Unterstützt lediglich Hinzufügen (Enqueue) und Entfernen (Dequeue)
	\\\\
	\textbf{Anwendungsfälle:}\\
	- Warteschlangen in Betriebssystemen für Prozessplanung\\
	- Puffer (Bspw. Datenverarbeitung)\\
	- Aufgabenwarteschlangen (Bspw. in Multi-Thread-Anwendungen)\\\\
	\textbf{Syntax:}
	\lstinputlisting[language=Java]{code/Queue.java} 
	\\
	\textbf{Funktionalität unter der Haube:}\\
	- Eine Queue kann bspw. durch ein Array oder eine verkettete Liste implementiert werden\\
	- Die Elemente werden auf der einen Seite (Rückseite) hinzugefügt und auf der anderen Seite (Vorderseite) entfernt\\
	- Schnelle Hinzufüge- und Entfernungsoperationen (konstante Laufzeit O(1))\\
	- \textbf{Spezialfall}: Double Ended Queue ermöglicht Operationen an beiden Seiten\\
	- \textbf{Spezialfall}: Priority Queue, wo Elemente nach Priorität in die Queue eingefügt werden (Über Comparator Interface umzusetzen)\\\\
	\textbf{Laufzeitkomplexität (Anhand LinkedList-basierter Queue)}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{5}{c}}
			\toprule
			Operation & Offer & Peak & Poll & Remove & Size  \\
			\midrule
			Time Complexity & $O(1)$ & $O(1)$ & $O(1)$ & $O(1)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsection{HashMap}
	Assoziative Datenstruktur, speichert Key-Value Paare
	Erlaubt extrem schnelles Suchen, Einfügen und Löschen durch Hash-Verfahren\\\\
	\textbf{Anwendungsfälle:}\\
	- Effiziente Suche nach Werten in großen Datenmengen\\
	- Implementierung von Caches\\
	- Verfolgung von Zählungen oder Häufigkeiten\\\\
	\textbf{Syntax:}
	\lstinputlisting[language=Java]{code/HashMap.java} 
	\\
	\textbf{Funktionalität unter der Haube:}\\
	- Implementiert häufig eine Hashtabelle, die Schlüssel in Indizes umwandelt, um Werte zu speichern und abzurufen\\
	- Verwendet Hashfunktionen, um Kollisionen zu minimieren und den Zugriff auf die Werte zu beschleunigen\\
	- Schnelle Einfüge-, Lösch- und Suchoperationen (konstante Laufzeit O(1)), aber bei Kollisionen (Zwei versch. Elemente, gleicher Hash) kann die Leistung abnehmen\\\\
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & Get & ContainsKey & Next\\
			\midrule
			Time Complexity & $O(1)$ & $O(1)$ & $O(h / n)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsection{Set}
	Ungeordnete Sammlung eindeutiger Elemente, somit keine Duplikate erlaubt\\\\
	\textbf{Anwendungsfälle:}\\
	- Überprüfen auf Eindeutigkeit von Elementen\\
	- Durchlaufen und Verarbeiten von eindeutigen Elementen\\
	- Mengenoperationen wie Vereinigung, Schnittmenge und Differenz\\\\
	\textbf{Syntax:}
	\lstinputlisting[language=Java]{code/HashMap.java} 
	\\
	\textbf{Funktionalität unter der Haube:}\\
	- Implementiert häufig eine Hashtabelle oder andere effiziente Mechanismen zur Überprüfung auf Eindeutigkeit\\
	- Verwendet Hashfunktionen, um schnelles Hinzufügen, Löschen und Überprüfen auf Eindeutigkeit zu ermöglichen\\
	- Schnelle Operationen für Mengenoperationen\\\\
	\textbf{Laufzeitkomplexität (Hash Table based)}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{5}{c}}
			\toprule
			Operation & Add & Remove & Contains & Next & Size\\
			\midrule
			Time Complexity & $O(1)$ & $O(1)$ & $O(1)$ & $O(h / n)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsection{Tree}
	Hierarchische Datenstruktur bestehend aus Knoten, die durch Kanten verbunden sind
	Verschiedene Arten von Bäumen: Suchbäume, AVL-Bäum, Heaps,..\\\\
	\textbf{Anwendungsfälle:}\\
	- Organisation von Daten in hierarchischen Strukturen\\
	- Schnelle Suche, Einfügung und Löschung von Elemente\\\\
	\textbf{Syntax:}
	\lstinputlisting[language=Java]{code/Tree.java} 
	\\
	\textbf{Funktionalität unter der Haube:}\\
	- \textbf{Einfügen (Hinzufügen):}\\
	\quad - Abhängig von der Art des Baumes, erfolgt das Hinzufügen von Elementen durch Traversieren und Einfügen an der richtigen Stelle.\\
	\quad - Bei binären Suchbäumen wird das Element entsprechend der Ordnungsregel eingefügt.\\
	\quad - Bei AVL-Bäumen erfolgt zusätzlich eine Balance-Anpassung, um die Höhe des Baumes zu minimieren und somit die Suche zu optimieren.\\\\
	- \textbf{Löschen (Entfernen):}\\
	\quad - Entfernen eines Elements erfordert ebenfalls eine Traversierung, um das Element zu finden.\\
	\quad - Je nach Art des Baumes müssen nach dem Entfernen gegebenenfalls Anpassungen vorgenommen werden, um die Baumstruktur beizubehalten.\\
	\quad - AVL-Bäume werden nach dem Löschen ebenfalls balanciert.\\\\
	- \textbf{Suchen (nach einem Element):}\\
	\quad - Suche erfolgt durch Traversieren des Baumes entsprechend der Ordnungsregel.\\
	\quad - Bei einem binären Suchbaum wird die Suche abhängig von der Vergleichsregel im Baum durchgeführt\\\\
	- \textbf{Durchlaufen aller Elemente:}\\
	\quad - Die Traversierung kann in-order, pre-order oder post-order erfolgen, je nach Anforderungen.\\
	\quad - \textit{In-order}: Linker Teilbaum, aktueller Knoten, rechter Teilbaum.\\
	\quad - \textit{Pre-order}: Aktueller Knoten, linker Teilbaum, rechter Teilbaum.\\
	\quad - \textit{Post-order}: Linker Teilbaum, rechter Teilbaum, aktueller Knoten.\\\\
	- \textbf{Spezialfall Min-Heap:}\\
	\quad - Das kleinste Element befindet sich an der Wurzel\\
	\quad - Jeder Elternknoten ist kleiner als oder gleich seinen Kindern\\
	\quad - Verwendung in der Implementierung von Prioritätswarteschlangen, wo das Element mit der höchsten Priorität (niedrigster Wert) immer an der Spitze steht\\\\
	- \textbf{Spezialfall Max-Heap:}\\
	\quad - Das größte Element befindet sich an der Wurzel\\
	\quad - Jeder Elternknoten ist größer als oder gleich seinen Kindern\\
	\quad - Auch in der Implementierung von Prioritätswarteschlangen verwendet, jedoch mit der höchsten Priorität an der Spitze\\\\
	- \textbf{Spezialfall AVL-Baum:}\\
	\quad - Ein ausbalancierter binärer Suchbaum, der sicherstellt, dass die Höhen der beiden Kindunterbäume jedes Knotens höchstens um eins voneinander abweichen\\
	\quad - Die Balance wird durch Rotationen (links oder rechts) bei Einfüge- oder Löschoperationen aufrechterhalten\\
	\quad - Die Balancierung sorgt für effiziente Suchoperationen, da die Höhe des Baumes minimiert wird\\\\
	
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & TODO & TODO & TODO\\
			\midrule
			Time Complexity & $TODO$ & $TODO$ & $TODO$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsection{Graph}
	Sammlung von Knoten (Vertices) und Kanten (Edges), welche Knoten verbinden.
	Kann gerichtet (Directed) oder ungerichtet (undirected sein)\\\\
	\textbf{Anwendungsfälle:}\\
	- Modellierung von Beziehungen in sozialen Netzwerken\\
	- Routing-Algorithmen in Computernetzwerken\\
	- Suche in Graphen, wie in der Tiefen- oder Breitensuche\\\\
	\textbf{Syntax:}
	\lstinputlisting[language=Java]{code/Graph.java} 
	\\
	\textbf{Funktionalität unter der Haube:}\\
	- Stark variierend je nach Umsetzung\\\
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{3}{c}}
			\toprule
			Operation & TODO & TODO & TODO \\
			\midrule
			Time Complexity & $TODO$ & $TODO$ & $TODO$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage


\end{document}
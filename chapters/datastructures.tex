% chapters/chapter1.tex
\documentclass[../main.tex]{subfiles}

\begin{document}
	
	\section{Datenstrukturen}
%		TEMPLATE
%		\subsection{ArrayList}
%		GENERELLE INFO. \\\\
%		\textbf{Anwendungsfälle:}\\
%		- TEXT\\
%		- TEXT\\\\
%		\textbf{Syntax:}
%		\lstinputlisting[language=Java]{code/ArrayList.java} 
%		\\
%		\textbf{Funktionalität unter der Haube:}\\
%		- TEXT\\
%		- TEXT\\\\
%		\textbf{Laufzeitkomplexität}\\
%		\begin{table}[ht]
%			\centering
%			\begin{tabular}{l *{6}{c}}
%				\toprule
%				Operation & Add & Remove & Get & Contains & Next & Size \\
%				\midrule
%				Time Complexity & $O(1)$ & $O(n)$ & $O(1)$ & $O(n)$ & $O(1)$ & $O(1)$ \\
%				\bottomrule
%			\end{tabular}
%		\end{table}
%		\clearpage		
	
		\subsection{ArrayList}
		Die ArrayList in Java ist eine dynamisch wachsende Liste, die auf dem zugrunde liegenden Array basiert.
		Sie erweitert die Funktionalität von Arrays durch automatische Größenanpassung und bietet eine flexible Möglichkeit, Elemente hinzuzufügen, zu löschen und darauf zuzugreifen. \\\\
		\textbf{Anwendungsfälle:}\\
		- Speicherung von Elementen einer Liste\\
		- Zugriff auf Elemente durch Index\\
		- Wenn die Größe der Liste nicht im Voraus bekannt ist\\ 
		- Wenn häufiger Einfüge- und Löschoperationen erforderlich sind\\\\
		\textbf{Syntax:}
		\lstinputlisting[language=Java]{code/ArrayList.java} 
		\\
		\textbf{Funktionalität unter der Haube:}\\
		- Intern durch Array verwaltet, welches ggf. neu dimensioniert werden muss\\
		- Neudimensionierung führt zu O(n), da neues Array und alle Elemente kopiert werden. Wird allerdings selten gemacht und dann i.d.R. direkt verdoppelt, somit amortisiert O(1)\\\\
		\textbf{Laufzeitkomplexität}\\
		\begin{table}[ht]
			\centering
			\begin{tabular}{l *{6}{c}}
				\toprule
				Operation & Add & Remove & Get & Contains & Next & Size \\
				\midrule
				Time Complexity & $O(1)$ & $O(n)$ & $O(1)$ & $O(n)$ & $O(1)$ & $O(1)$ \\
				\bottomrule
			\end{tabular}
		\end{table}
		\clearpage
		
		
		\subsection{LinkedList}
		Dynamische Datenstruktur bestehend aus Knoten, die jeweils auf den nächsten Knoten in der Sequenz zeigen
		Zwei Haupttypen: Singly Linked (Zeigt nur auf Nachfolger), Doubly Linked (Zeigt  auf Vor- und Nachfolger).\\\\
		\textbf{Anwendungsfälle:}\\
		- Bei häufigen Einfüge- und Löschoperationen an verschiedenen Positionen\\
		- Wenn die Größe der Liste variabel ist\\\\
		\textbf{Syntax:}
		\lstinputlisting[language=Java]{code/ArrayList.java} 
		\\
		\textbf{Funktionalität unter der Haube:}\\
		- Jeder Knoten erhält Verweise auf Nach- (ggf. Vorgänger)\\
		- Einfügen und Löschen an am Ende/Anfang konstant, ansonsten linear, da update der Verweise\\\\
		\textbf{Laufzeitkomplexität}\\
		\begin{table}[ht]
			\centering
			\begin{tabular}{l *{6}{c}}
				\toprule
				Operation & Add & Remove & Get & Contains & Next & Size \\
				\midrule
				Time Complexity & $O(1)$ & $O(1)$ & $O(n)$ & $O(n)$ & $O(1)$ & $O(1)$ \\
				\bottomrule
			\end{tabular}
		\end{table}
	\clearpage
		
		
	\subsection{Stack}
	Agiert nach \textbf{L}ast-\textbf{I}n-\textbf{F}irst-\textbf{O}ut (\textbf{LIFO}) Prinzip: Das letzte hinzugefügte Element wird als Erstes entfernt.
	Unterstützt lediglich Hinzufügen (Push) und Entfernen (Pop). \\\\
	\textbf{Anwendungsfälle:}\\
	- Rückverfolgung von Funktionsaufrufen (Call Stack Aufbau bspw.)\\
	- Umkehrung von Zeichenketten/Ausdrücken\\
	- Undo-Mechanismen\\\\
	\textbf{Syntax:}
	\lstinputlisting[language=Java]{code/Stack.java} 
	\\
	\textbf{Funktionalität unter der Haube:}\\
	- Ein Stack kann durch ein Array oder eine verkettete Liste implementiert werden\\
	- Die Elemente werden auf dem Stack oben hinzugefügt und entfernt\\
	- Schnelle Hinzufüge- und Entfernungsoperationen (konstante Laufzeit O(1))\\
	- Keine Suchmöglichkeit, ggf. aber Möglichkeit oberstes Element anzuschauen (peek)\\
	- Custom Suche implementierbar, dann O(n) wahrscheinlich\\\\
	\textbf{Laufzeitkomplexität}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{2}{c}}
			\toprule
			Operation & Push & Pop  \\
			\midrule
			Time Complexity & $O(1)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage
	
	\subsection{Queue}
	Agiert nach \textbf{F}irst-\textbf{I}n-\textbf{F}irst-\textbf{O}ut (\textbf{FIFO}) Prinzip: Das letzte hinzugefügte Element wird als Erstes entfernt.
	Unterstützt lediglich Hinzufügen (Enqueue) und Entfernen (Dequeue)
	\\\\
	\textbf{Anwendungsfälle:}\\
	- Warteschlangen in Betriebssystemen für Prozessplanung\\
	- Puffer (Bspw. Datenverarbeitung)\\
	- Aufgabenwarteschlangen (Bspw. in Multi-Thread-Anwendungen)\\\\
	\textbf{Syntax:}
	\lstinputlisting[language=Java]{code/Queue.java} 
	\\
	\textbf{Funktionalität unter der Haube:}\\
	- Eine Queue kann bspw. durch ein Array oder eine verkettete Liste implementiert werden\
	- Die Elemente werden auf der einen Seite (Rückseite) hinzugefügt und auf der anderen Seite (Vorderseite) entfernt\\
	- Schnelle Hinzufüge- und Entfernungsoperationen (konstante Laufzeit O(1))\\
	- \textbf{Spezialfall}: Double Ended Queue ermöglicht Operationen an beiden Seiten\\
	- \textbf{Spezialfall}: Priority Queue, wo Elemente nach Priorität in die Queue eingefügt werden (Über Comparator Interface umzusetzen)\\\\
	\textbf{Laufzeitkomplexität (Anhand LinkedList-basierter Queue)}\\
	\begin{table}[ht]
		\centering
		\begin{tabular}{l *{5}{c}}
			\toprule
			Operation & Offer & Peak & Poll & Remove & Size  \\
			\midrule
			Time Complexity & $O(1)$ & $O(1)$ & $O(1)$ & $O(1)$ & $O(1)$\\
			\bottomrule
		\end{tabular}
	\end{table}
	\clearpage

\end{document}